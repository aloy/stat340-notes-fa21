<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Using a continuous prior distribution</title>
    <meta charset="utf-8" />
    <meta name="author" content="Stat 340: Bayesian Statistics" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/hygge.css" rel="stylesheet" />
    <link href="libs/countdown/countdown.css" rel="stylesheet" />
    <script src="libs/countdown/countdown.js"></script>
    <link rel="stylesheet" href="assets/css/my-theme.css" type="text/css" />
    <link rel="stylesheet" href="assets/css/my-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: title-slide, left, middle
background-image: url(img/densities.png)
background-position: right
background-size: 45%

.left-wide[
# Using a continuous prior distribution

### Stat 340: Bayesian Statistics
]
---
class: middle

# 1. Continuous prior

# 2. Posterior analysis

# 3. Prediction

# (Problem topics 1-4)

---

## Blindsight design, redux


**Data:** N N N N **&lt;font color = "tomato"&gt;B B&lt;/font&gt;** N N N  **&lt;font color = "tomato"&gt;B&lt;/font&gt;** N N N N N N N (14 Ns; **&lt;font color = "tomato"&gt;3 Bs&lt;/font&gt;**)

&lt;br&gt;

**Data model (likelihood):**

Some true proportion of guesses, `\(p\)`

Toss a coin with probability of heads, `\(p\)`

&lt;br&gt;

**Belief about `\(p\)`:**

Uniform over (0, 1)

---
background-image: url(img/Beta-priors.png)
background-position: right
background-size:contain
## Beta distribution


- `\(f(x|a, b) = \frac{\Gamma(a + b)}{\Gamma(a) \Gamma(b)} x^{a-1} (1-x)^{b-1}\)`

- Parameter space: `\(a&gt;0\)`, `\(b&gt;0\)`

- Support: `\(0 &lt; x &lt; 1\)`

.footnote[Image credit: Probability and Bayesian Modeling]

---
class: middle
background-image: url("figs/002x006.png")
background-position: left
background-size: 50%

.pull-right[

# "The prior is proportional to the prior times the likelihood"
]

---
class: inverse

# Your turn 1

- Work with your neighbors

- Work through the R code to simulate kernels of the beta distribution

- You can copy/paste the code from the course webpage

- Develop your understanding of the kernel of a distribution


<div class="countdown" id="timer_61478741" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">05</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---
class: inverse

# Your turn 2


- Work with your neighbors

- Derive the posterior

- Are you working with a conjugate family?

<div class="countdown" id="timer_61478a3b" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">05</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>


---

## Posterior analysis

.pull-left[

&gt; To a Bayesian, the best information one can ever have about `\(\theta\)` is to know the posterior density.
&gt;
&gt; — Christensen, et al; *Bayesian Ideas and Data Analysis*, p. 31
]



&lt;img src="03-prop-continuous-prior_files/figure-html/unnamed-chunk-3-1.svg" width="50%" /&gt;


---

## Point estimates

.pull-left[
-  &lt;strong&gt;Posterior mean&lt;/strong&gt; &lt;/font&gt;

- &lt;font color = "#E69F00"&gt; &lt;strong&gt;Posterior median &lt;/strong&gt;&lt;/font&gt;

- &lt;font color = "#56B4E9"&gt; &lt;strong&gt;Posterior mode &lt;/strong&gt;&lt;/font&gt;  &lt;br&gt; i.e. *maximum a posteriori* (MAP) estimate

]


&lt;img src="03-prop-continuous-prior_files/figure-html/unnamed-chunk-4-1.svg" width="50%" /&gt;


---

## Credible intervals

&lt;img src="03-prop-continuous-prior_files/figure-html/ci1-1.svg" width="40%" style="display: block; margin: auto;" /&gt;


```r
# q*() functions calculate quantiles from the specified distribution
c(lower = qbeta(0.055, 15, 4), upper = qbeta(1 - 0.055, 15, 4))
```

```
##     lower     upper 
## 0.6288166 0.9177940
```

---

## Credible intervals are not unique

Here are three 89% credible intervals

&lt;br&gt;

&lt;img src="03-prop-continuous-prior_files/figure-html/ci2-1.svg" width="100%" /&gt;

---

## Testing a hypothesis

.large[
Suppose the researchers were interested in testing


.pull-left[

`\(H_0: p \le 0.5\)`

`\({\rm P}(p \le 0.5 | Y = 14) = 0.004\)`

![](03-prop-continuous-prior_files/figure-html/unnamed-chunk-6-1.svg)&lt;!-- --&gt;

]

.pull-right[

`\(H_1: p &gt; 0.5\)`

`\({\rm P}(p &gt; 0.5 | Y = 14) = 0.996\)`

![](03-prop-continuous-prior_files/figure-html/unnamed-chunk-7-1.svg)&lt;!-- --&gt;
]

]

---

## Predicting a new observation

To make predictions, we need to work with the **posterior predictive** distribution:

`\begin{align*}
f(\widetilde{Y} = \widetilde{y} | Y = y) &amp;= \int_0^1 f(\widetilde{Y} = \widetilde{y}, p | Y = y) dp\\
  &amp;= \int_0^1 f(\widetilde{Y} = \widetilde{y} | p, Y = y) \pi(p | Y = y) dp\\
  &amp;= \int_0^1 f(\widetilde{Y} = \widetilde{y} | p) \pi(p | Y = y) dp
\end{align*}`

.footnote[See Appendix B for algebraic work specific to the Binomial distribution]


---

## Monte Carlo simulation for prediction

Suppose we wish to make predictions for a new set of 20 "guesses" made by PS

Posterior predictive 
`$$f(\widetilde{Y} = \widetilde{y} | Y = 14) = \displaystyle \int_0^1 f(\widetilde{Y} = \widetilde{y} | p) \pi(p | Y = 14) dp$$`

Integration via simulation:





```r
n &lt;- 20   # No. of new binomial trials
S &lt;- 1000 # No. simulations
sim_p &lt;- rbeta(S, 15, 4)
sim_y &lt;- rbinom(S, size = n, prob = sim_p)
```

---

.left-wide[
## Posterior predictive distribution
&lt;img src="03-prop-continuous-prior_files/figure-html/unnamed-chunk-10-1.svg" width="95%" /&gt;
]

.right-narrow[

```r
janitor::tabyl(sim_y)
```

```
##  sim_y   n percent
##      5   2   0.002
##      7   3   0.003
##      8   4   0.004
##      9   5   0.005
##     10  22   0.022
##     11  28   0.028
##     12  54   0.054
##     13  84   0.084
##     14  85   0.085
##     15 126   0.126
##     16 135   0.135
##     17 167   0.167
##     18 148   0.148
##     19 103   0.103
##     20  34   0.034
```
]

---

## Prediction intervals

How can we construct an 89% prediction interval?

Put in the most likely values until the probability is **at least** 0.89


```r
post_pred_dsn &lt;- janitor::tabyl(sim_y)[, -2]
LearnBayes::discint(post_pred_dsn, prob = 0.89)
```

```
## $prob
## [1] 0.902
## 
## $set
## [1] 12 13 14 15 16 17 18 19
```

---
class: inverse 

# Your turn 3

Let  `\(p\)` denote the proportion of U.S. adults that do not believe in climate change. Of 1000 survey respondents, 150 responded that it was "not real at all".

1. Using a Beta(1, 2) prior distribution, what is the posterior distribution of `\(p\)`?

2. Simulate 1000 draws from the posterior distribution.

3. Use your simulated draws to calculate a 93% credible interval
 equal-tailed for `\(p\)`. Interpret this interval in context.

4. Suppose you were to survey 100 more adults. Approximate the probability that at least 20 of the 100 people don’t believe in climate change.

.footnote[https://thepulseofthenation.com/, data from September 2017. ]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"output": null,
"ratio": "16:9",
"highlightStyle": "solarized-light",
"highlightLanguage": ["r", "css", "yaml"],
"highlightLines": true,
"countIncrementalSlides": false,
"slideNumberFormat": "%current%"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
