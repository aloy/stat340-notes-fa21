<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Hierarchical models</title>
    <meta charset="utf-8" />
    <meta name="author" content="Stat 340: Bayesian Statistics" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/hygge.css" rel="stylesheet" />
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/countdown/countdown.css" rel="stylesheet" />
    <script src="libs/countdown/countdown.js"></script>
    <link rel="stylesheet" href="assets/css/my-theme.css" type="text/css" />
    <link rel="stylesheet" href="assets/css/my-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">




class: title-slide, left, middle

# Hierarchical models

### Stat 340: Bayesian Statistics


---

## Example: ELS math scores

- 2002 Educational Longitudinal Study (ELS)

- Survey from schools across the United States

- Data are collected by sampling schools and then sampling students within each selected school

- We'll focus on 10th grade math scores from a sample of 10 schools

- Math tests contained items in arithmetic, algebra, geometry, data/probability, and advanced topics were divided into process categories of skill/knowledge, understanding/ comprehension, and problem solving

---

## ELS math scores

.left-wide[
&lt;img src="18-hierarchical-normal2_files/figure-html/unnamed-chunk-1-1.svg" width="98%" /&gt;
]

.right-narrow[
Possible questions:

- What’s the typical math score?

- To what extent do scores vary from school to school?

- For any single school, how much might scores vary from student to student?
]

---

## Possible analysis strategies

.bold[Complete pooling (combined estimates)]&lt;br&gt;
Ignore schools and lump all students together

--

.bold[No pooling (separate groups)]&lt;br&gt;
Separately analyze each school and assume that one school’s data doesn’t contain valuable information about another school

--

.bold[Partial pooling (compromise estimates)]&lt;br&gt;
Acknowledge the grouping structure, so that even though schools differ in performance, they might share valuable information about each other and about the broader population of schools

---

## What have we seen so far?

- Completely pooled model does not acknowledge differences between schools

- No pooled model acknowledges that some schools tend to score higher than others

- No pooled model ignores data on one school when learning about the typical score of another

- No pooled model cannot be generalized to schools outside our sample

---

## Hierarchical model

Let's compromise between the the complete pooled and no pooled models 

How? By using a *two-stage prior* specification

---

#### Hierarchical model specification for JAGS

.code100[

```r
modelString &lt;-"model {

## sampling
for (i in 1:N){
   y[i] ~ dnorm(mu_j[school[i]], invsigma2)
}

## priors
for (j in 1:J){
   mu_j[j] ~ dnorm(mu, invtau2)
}

invsigma2 ~ dgamma(a_s, b_s)
sigma &lt;- sqrt(pow(invsigma2, -1))

## hyperpriors
mu ~ dnorm(mu0, g0)
invtau2 ~ dgamma(a_t, b_t)
tau &lt;- sqrt(pow(invtau2, -1))
}
"
```
]

---

#### Define the data and prior parameters



```r
y &lt;- sub_school$mathscore      
school &lt;- sub_school$school
N &lt;- length(y)  
J &lt;- length(unique(school)) 
the_data &lt;- list(y = y, school = school, 
                 N = N, J = J,
                 mu0 = 50, g0 = .04,  # prior parameters
                 a_t = 1, b_t = .01,  # hyperparameters
                 a_s = 1, b_s = .01)  # hyperparameters
```

---

#### Run MCMC


```r
posterior &lt;- run.jags(
  modelString,
  n.chains = 1,
  data = the_data,
  monitor = c("mu", "tau", "mu_j", "sigma"),
  adapt = 1000,
  burnin = 5000,
  sample = 5000,
  silent.jags = TRUE
)
```

---

.code100[

```r
print(posterior, digits = 3)  
```

```
## 
## JAGS model summary statistics from 5000 samples (adapt+burnin = 6000):
##                                                                              
##         Lower95 Median Upper95 Mean    SD Mode  MCerr MC%ofSD SSeff     AC.10
## mu         45.7   51.8    57.9 51.7  3.06 51.9 0.0474     1.6  4156   -0.0257
## tau        3.62   7.61    14.1 8.19  3.03 6.87 0.0538     1.8  3178   -0.0105
## mu_j[1]    36.1   39.9    43.8 39.9     2 39.9 0.0319     1.6  3922   0.00146
## mu_j[2]    44.1   47.4    50.8 47.4  1.69 47.3 0.0241     1.4  4960   0.00413
## mu_j[3]    53.6   56.6      60 56.7  1.67 56.7 0.0236     1.4  4978    0.0174
## mu_j[4]    52.7   57.3    61.7 57.3  2.32 57.6 0.0344     1.5  4549    -0.015
## mu_j[5]    54.5   61.9    69.3   62  3.88 62.2 0.0651     1.7  3555   -0.0172
## sigma      6.68   7.92    9.28 7.97 0.683 7.83 0.0106     1.6  4121 -0.000238
##             
##         psrf
## mu        --
## tau       --
## mu_j[1]   --
## mu_j[2]   --
## mu_j[3]   --
## mu_j[4]   --
## mu_j[5]   --
## sigma     --
## 
## Total time taken: 0.9 seconds
```
]

---


```r
mcmc_intervals(posterior$mcmc, regex_pars = "mu")
```

&lt;img src="18-hierarchical-normal2_files/figure-html/unnamed-chunk-6-1.svg" width="85%" /&gt;

---

## Hierarchical predictions vs. sample means

&lt;img src="18-hierarchical-normal2_files/figure-html/unnamed-chunk-7-1.svg" width="90%" style="display: block; margin: auto;" /&gt;

---
background-image: url(img/bayesrule-hierarchical-varcomp.png)
background-size: 100%
background-position: middle
## Comparing sources of variability

.flex[
.left-col[
.hidden[X]between &gt; within
]

.middle-col[
.hidden[XX]between `\(\approx\)` within
]

.right-col[
.hidden[XXXX]between &lt; within
]
]

---

## Within-group (intraclass) correlation

Suppose we're in the situation where between group variability is much larger than within group variability

.pull-left[
&lt;img src="img/bayesrule-hierarchical-varcomp2.png" width="1163" /&gt;
]

.pull-right[
- Two observations within the same group are more similar than two observations from different groups

- Observations within the same group are correlated &lt;br&gt;(generally true, easier to see in this extreme case)
]

---

## Full ELS data set

&lt;img src="18-hierarchical-normal2_files/figure-html/unnamed-chunk-9-1.svg" width="100%" /&gt;

- 100 schools from urban settings in the full data set

- Sample sizes range from 4 to 32 students


```r
full_data &lt;- list(
  y = els$mathscore, 
  school = els$school, 
  N = nrow(els), 
  J = nlevels(els$school),
  mu0 = 50, g0 = .04,  # prior parameters
  a_t = 1, b_t = .01,  # hyperparameters
  a_s = 1, b_s = .01   # hyperparameters
)

posterior_full &lt;- run.jags(
  modelString,
  n.chains = 1,
  data = full_data,
  monitor = c("mu", "tau", "mu_j", "sigma"),
  adapt = 1000,
  burnin = 5000,
  sample = 5000,
  silent.jags = TRUE
)

post_intervals &lt;- mcmc_intervals_data(posterior_full$mcmc, regex_pars = "mu")
```

---

## ELS intraclass correlation



```r
draws &lt;- posterior_full$mcmc[[1]]
icc &lt;- draws[,"tau"]^2 / (draws[,"tau"]^2 + draws[,"sigma"]^2)
```

.left-wide[
&lt;img src="18-hierarchical-normal2_files/figure-html/unnamed-chunk-12-1.svg" width="95%" style="display: block; margin: auto;" /&gt;
]

.right-narrow[
90% credible interval:

```
##    5%   95% 
## 0.164 0.262
```
]

---

## ELS global mean

Inference for the global parameters proceeds as always

.left-wide[
&lt;img src="18-hierarchical-normal2_files/figure-html/unnamed-chunk-14-1.svg" width="95%" style="display: block; margin: auto;" /&gt;
]

.right-narrow[
90% credible interval:

```
##    5%   95% 
## 47.28 48.99
```
]

---

## Inference for group-specific means

There are often *a lot* of parameters to manage for group-specific inference

&lt;img src="18-hierarchical-normal2_files/figure-html/unnamed-chunk-16-1.svg" width="100%" /&gt;

---

class: inverse

## Your turn

School 3 and 17 have roughly the same posterior mean, but substantially different credible interval widths

Discuss with a neighbor why you think this difference occurs.

![](18-hierarchical-normal2_files/figure-html/unnamed-chunk-17-1.svg)&lt;!-- --&gt;

<div class="countdown" id="timer_617f7fe8" style="right:0;bottom:0;" data-warnwhen="0">
<code class="countdown-time"><span class="countdown-digits minutes">02</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

---

## Prediction for observed group

Suppose we want to make a prediction for school 13, then we need a posterior predictive distribution


```r
# Work with a data frame
post_df &lt;- as.data.frame(posterior_full$mcmc[[1]])

# Create the posterior predictive via simulation
pp_school13 &lt;- post_df %&gt;%
  select(mu_j = "mu_j[13]", sigma) %&gt;%               # select relevant cols
  mutate(y_pred = rnorm(nrow(post_df), mu_j, sigma)) # simulate a new obs.

# Check it out
head(pp_school13, 3)
```

```
##          mu_j    sigma   y_pred
## 6001 41.04391 9.348647 17.76017
## 6002 43.43353 9.285637 52.01264
## 6003 41.57400 9.101547 38.62476
```

---

## Prediction for unobserved group

Suppose we want to make a prediction for a school we didn't observe, let's call it school 101


```r
# Create the posterior predictive via simulation
pp_school101 &lt;- post_df %&gt;%
  select(mu, tau, sigma) %&gt;%                   # select global params
  mutate(
    mu_j = rnorm(nrow(post_df), mu, tau),      # generate mu_j
    y_pred = rnorm(nrow(post_df), mu_j, sigma) # generate y
  ) 

# Check it out
head(pp_school101, 3)
```

```
##            mu      tau    sigma     mu_j   y_pred
## 6001 48.98863 4.967225 9.348647 40.99028 51.17038
## 6002 48.36430 4.651078 9.285637 46.81391 39.47738
## 6003 47.56924 5.185095 9.101547 41.29647 42.03361
```

---

## How do the predictions compare?

&lt;img src="18-hierarchical-normal2_files/figure-html/unnamed-chunk-21-1.svg" width="70%" /&gt;

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"output": null,
"ratio": "16:9",
"highlightStyle": "solarized-light",
"highlightLanguage": ["r", "css", "yaml"],
"highlightLines": true,
"countIncrementalSlides": false,
"slideNumberFormat": "%current%"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
