---
title: "MCMC software"
author: "Stat 340: Bayesian Statistics"
output:
  xaringan::moon_reader:
    css: ["default", "assets/css/my-theme.css", "assets/css/my-fonts.css", "hygge"]
    seal: false
    lib_dir: libs
    nature:
      output:
      ratio: '16:9'
      highlightStyle: solarized-light
      highlightLanguage: ["r", "css", "yaml"]
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: "%current%"
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(dev = 'svg')
xaringanExtra::use_tachyons()
library(runjags)
library(coda)
library(countdown)
library(bayesplot)
library(ggplot2)
```

class: title-slide, left, middle
background-image: url("img/run_mcmc.jpg")
background-position: right
background-size: 50%

# `r rmarkdown::metadata$title`

### `r rmarkdown::metadata$author`


---
class: middle

# Implementing MCMC in JAGS

## (Problem topic 9)

---

## Example

- Researchers are interested in modeling the survival times, measured in weeks, of patients who were diagnosed with leukemia. 

- The patients were classified according to two characteristics of white bloods cells. 

- The sample consists of $n=17$ times in weeks from diagnosis to death

  ```{r}
  survival_times <- c(65, 156, 100, 134, 16, 108, 121, 4, 
                        39, 143, 56, 26, 22, 1, 1, 5, 65)
  ```

---
background-image: url(img/weibull_examples.png)
background-position: bottom
background-size: 65%

## Weibull distribution

Weibull distribution is often used as a model for survival times in biomedical, demographic, and engineering analyses

.bold[PDF]: $f(y | v, \lambda) = \lambda \alpha y^{\alpha-1} e^{-\lambda y^{\alpha}}, \quad y, \alpha, \lambda > 0$

.bold[CDF]: $F(y | v, \lambda) = 1 - e^{-\lambda y^{\alpha}}$



---

## Proposed model

.pull-left[
Let $Y_i =$ survival time in weeks

$Y_i | \alpha, \lambda \overset{\rm iid}{\sim} {\rm Weibull}(\alpha, \lambda)$

$\alpha \sim {\rm Gamma}(1, 1)$

$\lambda \sim {\rm Gamma}(1.53, 26.3)$

$\alpha \propto \lambda$
]

```{r echo=FALSE, message=FALSE, fig.height = 2.5, fig.width = 3.5, warning=FALSE, error=FALSE, include=FALSE}
model_string <- "
model{ 
  alpha ~ dgamma(1, 1)
  lambda ~ dgamma(1.53, 26.3)
  y ~ dweib(alpha, lambda)
}
"

prior_pred <- run.jags(
  model = model_string, #<<
  n.chains = 1,
  data = NULL,
  monitor = "y",
  adapt = 0,
  burnin = 0,
  sample = 5000,
  silent.jags = TRUE
)
```

.pull-right[
```{r echo=FALSE, message=FALSE, fig.height = 2.5, fig.width = 3.5, warning=FALSE, error=FALSE, out.width = "100%"}
mcmc_dens(as.mcmc(prior_pred)) + 
  xlim(c(0, 500)) + 
  xlab("Surival time (weeks)") +
  ggtitle("Prior predictive")
```
]


---

class: inverse

# Your turn

Weibull PDF: $f(y | v, \lambda) = \lambda \alpha y^{\alpha-1} e^{-\lambda y^{\alpha}}$

Gamma PDF: $f(x | a, b) = \dfrac{b^a}{\Gamma(a)} x^{a-1} e^{-bx}$

1. Derive the joint posterior distribution for] $\alpha$ and $\lambda$

1. Derive the two conditional posterior distributions for this model

1. Are either distributions that you recognize?

1. If you get done, outline the steps of a Gibbs sampler for this posterior

```{r echo=FALSE}
countdown(5)
```


---

# Why Just Another Gibbs Sampler (JAGS)?

- You can fit virtually any model

- You can call JAGS from R, allowing for plotting and
data manipulation in R

- It runs on all platforms: LINUX, Mac, Windows

- There is a lot of help online

- R has many built in packages for convergence diagnostics

.footnote[Slide adapted from Brian Reich]

---

# How does JAGS work?


- You specify the model by declaring the likelihood and priors

- JAGS then sets up the MCMC sampler
    + e.g., works out the full conditional distributions for all parameters

- It returns MCMC samples in a matrix or array

- It also automatically produces posterior summaries like
means, credible sets, and convergence diagnostics

- Userâ€™s manual: http://people.stat.sc.edu/hansont/stat740/jags_user_manual.pdf


.footnote[Slide adapted from Brian Reich]

---

# Steps for any analysis using JAGS


1. Specify the model as a string (or script)

2. Define/load the data

3. Define initial values

4. Draw posterior samples using `run.jags()` 

5. Inspect/summarize the results


---
class: middle

## 0. Load `runjags`

```{r message=FALSE}
library(runjags)
```

---

## 1. Specify the model as a string

```{r}
model_string <- "
model{ 
  # Specify the likelihood
  for(i in 1:n) {
    y[i] ~ dweib(alpha, lambda)
  }
  
  # Specify the priors
  alpha ~ dgamma(1, 1)
  lambda ~ dgamma(1.53, 26.3)
}
"
```

---
background-image: url(img/distributions_jags.png)
background-size: 68%
background-position: right

.left-narrow[

## JAGS syntax

JAGS doesn't always use <br> the same syntax as R.

But, uses the same<br> `d*`, `q*`, and `p*` prefixes


.footnote[Image source: JAGS manual]
]



---

## 2. Define/load the data 

Loading the survival data
```{r}
survival_times <- c(65, 156, 100, 134, 16, 108, 121, 4, 
                    39, 143, 56, 26, 22, 1, 1, 5, 65)
```

Store your data in a list
```{r}
survival_data <- list(
  y = survival_times,
  n = length(survival_times)
)
```

---


## 3. Define initial values

- If you don't specify initial values for your parameters, then JAGS will 

- If not specified,  then JAGS will use the mean or mode of the prior distribution

- More on this next time...

---

## 4. Draw posterior samples using `run.jags()` 

.left-wide[
- `model` string specifying the model
]

.right-narrow[
```{r eval=FALSE}
posterior <- run.jags(
  model = model_string, #<<
  n.chains = 1,
  data = survival_data,
  monitor = c("alpha", "lambda"),
  adapt = 1000,
  burnin = 5000,
  sample = 5000
)
```
]

---

## 4. Draw posterior samples using `run.jags()` 

.left-wide[
- `model` string specifying the model
- `n.chains` the number of chains to run
]

.right-narrow[
```{r eval=FALSE}
posterior <- run.jags(
  model = model_string, 
  n.chains = 1, #<<
  data = survival_data,
  monitor = c("alpha", "lambda"),
  adapt = 1000,
  burnin = 5000,
  sample = 5000
)
```
]

---

## 4. Draw posterior samples using `run.jags()` 

.left-wide[
- `model` string specifying the model
- `n.chains` the number of chains to run
- `data` a named list or data frame include the data and prior parameter values
]

.right-narrow[
```{r eval=FALSE}
posterior <- run.jags(
  model = model_string, 
  n.chains = 1, 
  data = survival_data, #<<
  monitor = c("alpha", "lambda"),
  adapt = 1000,
  burnin = 5000,
  sample = 5000
)
```
]

---

## 4. Draw posterior samples using `run.jags()` 

.left-wide[
- `model` string specifying the model
- `n.chains` the number of chains to run
- `data` a named list or data frame include the data and prior parameter values
- `monitor` character vector of the names of variables to monitor
]

.right-narrow[
```{r eval=FALSE}
posterior <- run.jags(
  model = model_string, 
  n.chains = 1, 
  data = survival_data, 
  monitor = c("alpha", "lambda"), #<<
  adapt = 1000,
  burnin = 5000,
  sample = 5000
)
```
]

---


## 4. Draw posterior samples using `run.jags()` 

.left-wide[
- `model` string specifying the model
- `n.chains` the number of chains to run
- `data` a named list or data frame include the data and prior parameter values
- `monitor` character vector of the names of variables to monitor
- `adapt` number of samples drawn during initial sampling/adaptation phase
]

.right-narrow[
```{r eval=FALSE}
posterior <- run.jags(
  model = model_string, 
  n.chains = 1, 
  data = survival_data, 
  monitor = c("alpha", "lambda"),
  adapt = 1000,  #<<
  burnin = 5000,
  sample = 5000
)
```
]

---


## 4. Draw posterior samples using `run.jags()` 

.left-wide[
- `model` string specifying the model
- `n.chains` the number of chains to run
- `data` a named list or data frame include the data and prior parameter values
- `monitor` character vector of the names of variables to monitor
- `adapt` number of samples drawn during initial sampling/adaptation phase
- `burnin` number of burn-in iterations, NOT including the adaptive iterations
]

.right-narrow[
```{r eval=FALSE}
posterior <- run.jags(
  model = model_string, 
  n.chains = 1, 
  data = survival_data, 
  monitor = c("alpha", "lambda"),
  adapt = 1000,  
  burnin = 5000, #<<
  sample = 5000
)
```
]

---



## 4. Draw posterior samples using `run.jags()` 

.left-wide[
- `model` string specifying the model
- `n.chains` the number of chains to run
- `data` a named list or data frame include the data and prior parameter values
- `monitor` character vector of the names of variables to monitor
- `adapt` number of samples drawn during initial sampling/adaptation phase
- `burnin` number of burn-in iterations, NOT including the adaptive iterations
- `sample` the total number of (additional) samples to draw
]

.right-narrow[
```{r run-jags, eval=FALSE}
posterior <- run.jags(
  model = model_string, 
  n.chains = 1, 
  data = survival_data, 
  monitor = c("alpha", "lambda"),
  adapt = 1000,  
  burnin = 5000, 
  sample = 5000 #<<
)
```
]

---
class: clear

In an .Rmd file, add `silent.jags = TRUE` to avoid this issue...

```{r run-jags, eval=TRUE, echo=FALSE}
```



---

```{r plot-posterior, fig.height = 4.5, fig.width = 8, message=FALSE, warning=FALSE, echo=FALSE, include=FALSE}
svg("figs/plot-survival-posterior1.svg", height = 6, width = 6)
plot(posterior, vars = "alpha", plot.type = c("trace", "ecdf", "histogram", "autocorr"))
dev.off()

svg("figs/plot-survival-posterior2.svg", height = 6, width = 6)
plot(posterior, vars = "lambda", plot.type = c("trace", "ecdf", "histogram", "autocorr"))
dev.off()
```

background-image: url("figs/plot-survival-posterior1.svg"), url("figs/plot-survival-posterior2.svg")
background-position: left bottom, right bottom
background-size: 50%, 50%

## 5. Inspect the results



---


class: clear

`runjags` objects are big lists

```{r}
names(posterior)
```

---

`mcmc` element is a list of the actual draws

```{r}
head(posterior$mcmc)
```

---

## 5. Summarize the results

```{r collapse=TRUE}
summary(posterior$mcmc[[1]])
```


---

## `bayesplot`

- provides a variety of `ggplot2`-based plotting functions for use after fitting Bayesian models

- Visualizations of MCMC simulations and diagnostics *from any algorithm* (`mcmc_*`)

- Graphical prior and posterior predictive checks (`ppc_*`)

---

## Convert to an `mcmc` object

`bayesplot` requires objects to be of class `mcmc`

You'll need to convert your output from `run.jags()`

```{r collapse=TRUE}
class(posterior)
```

```{r collapse=TRUE}
post_mcmc <- as.mcmc(posterior)
class(post_mcmc)
```

---

## Trace plot

```{r fig.height = 3.5, fig.width = 7, out.width = "80%", fig.align='center'}
mcmc_trace(post_mcmc)
```

---

## ACF plot

```{r fig.height = 3.5, fig.width = 7, out.width = "80%", fig.align='center'}
mcmc_acf(post_mcmc)
```

---

## Posterior density plot

```{r fig.height = 3.5, fig.width = 7, out.width = "80%", fig.align='center'}
mcmc_dens(post_mcmc)
```

---

## Plot equal-tail interval estimates

```{r fig.height = 3.5, fig.width = 7, out.width = "80%", fig.align='center'}
mcmc_areas(post_mcmc)
```

---

class: inverse

# Your turn

.Large[.bold[The median survival time can be calculated as]] $\Large \left(\dfrac{\log(2)}{\lambda} \right)^{1/\alpha}$

.Large[.bold[How could you calculate a 90% credible interval for the median survival time?]]


```{r echo=FALSE}
countdown(1, 30)
```


---

## Posterior inference for `runjags` objects

.code90[
```{r}
median_survive <- (log(2) / posterior$mcmc[[1]][,"lambda"])^(1 / posterior$mcmc[[1]][,"alpha"])
```
]

.pull-left[
```{r echo=FALSE, fig.height=2, fig.width=3.5, message=FALSE, out.width = "100%"}
ggplot() + 
  geom_histogram(aes(x = median_survive, y = ..density..)) +
  labs(x = "median survival time (weeks)")
```
]

.pull-right[
90% credible interval for the median survival time

.code90[
```{r collapse=TRUE}
quantile(median_survive, 
         probs = c(0.05, 0.95))
```
]
]

---

## Monitoring functions of parameters

You can create objects in JAGS using `<-`

```{r}
model_string2 <- "
model{ 
  # Specify the likelihood
  for(i in 1:n) {
    y[i] ~ dweib(alpha, lambda)
  }
  
  # Specify the priors
  alpha ~ dgamma(1, 1)
  lambda ~ dgamma(1.53, 26.3)
  
  # Calculate median
  median <- (log(2) / lambda)^(1 / alpha) #<<
}
"
```

---

## Monitoring functions of parameters

You can monitor objects you create

```{r run-jags2, eval=FALSE}
posterior2 <- run.jags(
  model = model_string2,
  n.chains = 1, 
  data = survival_data, 
  monitor = "median", #<<
  adapt = 1000,  
  burnin = 5000, 
  sample = 5000 
)
```

---

```{r run-jags2, include=FALSE}
```

## Did the chain converge?

```{r echo=FALSE, fig.height = 3, fig.width = 9, out.width = "100%"}
posterior2 <- as.mcmc(posterior2)
mcmc_combo(posterior2, combo = c("dens", "trace", "acf"))
```



---

class: inverse

# Your turn

.Large[.bolder[Work through the example on the JAGS handout with a neighbor.]]

.Large[.bolder[Check the website for a .Rmd template]]

